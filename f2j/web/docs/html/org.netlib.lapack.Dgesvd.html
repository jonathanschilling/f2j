<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2//EN">
<!--NewPage-->
<html>
<head>
<!-- Generated by javadoc on Fri Jan 22 13:19:44 EST 1999 -->
<title>
  Class org.netlib.lapack.Dgesvd
</title>
</head>
<body>
<a name="_top_"></a>
<pre>
<a href="packages.html">All Packages</a>  <a href="tree.html">Class Hierarchy</a>  <a href="Package-org.netlib.lapack.html">This Package</a>  <a href="org.netlib.lapack.Dgesv.html#_top_">Previous</a>  <a href="org.netlib.lapack.Dgesvx.html#_top_">Next</a>  <a href="AllNames.html">Index</a></pre>
<hr>
<h1>
  Class org.netlib.lapack.Dgesvd
</h1>
<pre>
java.lang.Object
   |
   +----org.netlib.lapack.Dgesvd
</pre>
<hr>
<dl>
  <dt> public class <b>Dgesvd</b>
  <dt> extends Object
</dl>
<pre>
Following is the description from the original
Fortran source.  For each array argument, the Java
version will include an integer offset parameter, so
the arguments may not match the description exactly.
Contact <a href="mailto:seymour@cs.utk.edu">seymour@cs.utk.edu</a> with any questions.
<p>
 *     ..
 *
 *  Purpose
 *  =======
 *
 *  DGESVD computes the singular value decomposition (SVD) of a real
 *  M-by-N matrix A, optionally computing the left and/or right singular
 *  vectors. The SVD is written
 *
 *       A = U * SIGMA * transpose(V)
 *
 *  where SIGMA is an M-by-N matrix which is zero except for its
 *  min(m,n) diagonal elements, U is an M-by-M orthogonal matrix, and
 *  V is an N-by-N orthogonal matrix.  The diagonal elements of SIGMA
 *  are the singular values of A; they are real and non-negative, and
 *  are returned in descending order.  The first min(m,n) columns of
 *  U and V are the left and right singular vectors of A.
 *
 *  Note that the routine returns V**T, not V.
 *
 *  Arguments
 *  =========
 *
 *  JOBU    (input) CHARACTER*1
 *          Specifies options for computing all or part of the matrix U:
 *          = 'A':  all M columns of U are returned in array U:
 *          = 'S':  the first min(m,n) columns of U (the left singular
 *                  vectors) are returned in the array U;
 *          = 'O':  the first min(m,n) columns of U (the left singular
 *                  vectors) are overwritten on the array A;
 *          = 'N':  no columns of U (no left singular vectors) are
 *                  computed.
 *
 *  JOBVT   (input) CHARACTER*1
 *          Specifies options for computing all or part of the matrix
 *          V**T:
 *          = 'A':  all N rows of V**T are returned in the array VT;
 *          = 'S':  the first min(m,n) rows of V**T (the right singular
 *                  vectors) are returned in the array VT;
 *          = 'O':  the first min(m,n) rows of V**T (the right singular
 *                  vectors) are overwritten on the array A;
 *          = 'N':  no rows of V**T (no right singular vectors) are
 *                  computed.
 *
 *          JOBVT and JOBU cannot both be 'O'.
 *
 *  M       (input) INTEGER
 *          The number of rows of the input matrix A.  M >= 0.
 *
 *  N       (input) INTEGER
 *          The number of columns of the input matrix A.  N >= 0.
 *
 *  A       (input/output) DOUBLE PRECISION array, dimension (LDA,N)
 *          On entry, the M-by-N matrix A.
 *          On exit,
 *          if JOBU = 'O',  A is overwritten with the first min(m,n)
 *                          columns of U (the left singular vectors,
 *                          stored columnwise);
 *          if JOBVT = 'O', A is overwritten with the first min(m,n)
 *                          rows of V**T (the right singular vectors,
 *                          stored rowwise);
 *          if JOBU .ne. 'O' and JOBVT .ne. 'O', the contents of A
 *                          are destroyed.
 *
 *  LDA     (input) INTEGER
 *          The leading dimension of the array A.  LDA >= max(1,M).
 *
 *  S       (output) DOUBLE PRECISION array, dimension (min(M,N))
 *          The singular values of A, sorted so that S(i) >= S(i+1).
 *
 *  U       (output) DOUBLE PRECISION array, dimension (LDU,UCOL)
 *          (LDU,M) if JOBU = 'A' or (LDU,min(M,N)) if JOBU = 'S'.
 *          If JOBU = 'A', U contains the M-by-M orthogonal matrix U;
 *          if JOBU = 'S', U contains the first min(m,n) columns of U
 *          (the left singular vectors, stored columnwise);
 *          if JOBU = 'N' or 'O', U is not referenced.
 *
 *  LDU     (input) INTEGER
 *          The leading dimension of the array U.  LDU >= 1; if
 *          JOBU = 'S' or 'A', LDU >= M.
 *
 *  VT      (output) DOUBLE PRECISION array, dimension (LDVT,N)
 *          If JOBVT = 'A', VT contains the N-by-N orthogonal matrix
 *          V**T;
 *          if JOBVT = 'S', VT contains the first min(m,n) rows of
 *          V**T (the right singular vectors, stored rowwise);
 *          if JOBVT = 'N' or 'O', VT is not referenced.
 *
 *  LDVT    (input) INTEGER
 *          The leading dimension of the array VT.  LDVT >= 1; if
 *          JOBVT = 'A', LDVT >= N; if JOBVT = 'S', LDVT >= min(M,N).
 *
 *  WORK    (workspace/output) DOUBLE PRECISION array, dimension (LWORK)
 *          On exit, if INFO = 0, WORK(1) returns the optimal LWORK;
 *          if INFO > 0, WORK(2:MIN(M,N)) contains the unconverged
 *          superdiagonal elements of an upper bidiagonal matrix B
 *          whose diagonal is in S (not necessarily sorted). B
 *          satisfies A = U * B * VT, so it has the same singular values
 *          as A, and singular vectors related by U and VT.
 *
 *  LWORK   (input) INTEGER
 *          The dimension of the array WORK. LWORK >= 1.
 *          LWORK >= MAX(3*MIN(M,N)+MAX(M,N),5*MIN(M,N)-4).
 *          For good performance, LWORK should generally be larger.
 *
 *  INFO    (output) INTEGER
 *          = 0:  successful exit.
 *          < 0:  if INFO = -i, the i-th argument had an illegal value.
 *          > 0:  if DBDSQR did not converge, INFO specifies how many
 *                superdiagonals of an intermediate bidiagonal form B
 *                did not converge to zero. See the description of WORK
 *                above for details.
 *
 *  =====================================================================
 *
 *     .. Parameters ..
</pre>
<p>
<hr>
<a name="index"></a>
<h2>
  <img src="images/constructor-index.gif" width=275 height=38 alt="Constructor Index">
</h2>
<dl>
  <dt> <img src="images/yellow-ball-small.gif" width=6 height=6 alt=" o ">
	<a href="#Dgesvd()"><b>Dgesvd</b></a>()
  <dd> 
</dl>
<h2>
  <img src="images/method-index.gif" width=207 height=38 alt="Method Index">
</h2>
<dl>
  <dt> <img src="images/green-ball-small.gif" width=6 height=6 alt=" o ">
	<a href="#dgesvd(java.lang.String, java.lang.String, int, int, double[], int, int, double[], int, double[], int, int, double[], int, int, double[], int, int, org.netlib.util.intW)"><b>dgesvd</b></a>(String, String, int, int, double[], int, int, double[], int, double[], int, int, double[], int, int, double[], int, int, intW)
  <dd> 
</dl>
<a name="constructors"></a>
<h2>
  <img src="images/constructors.gif" width=231 height=38 alt="Constructors">
</h2>
<a name="Dgesvd"></a>
<a name="Dgesvd()"><img src="images/yellow-ball.gif" width=12 height=12 alt=" o "></a>
<b>Dgesvd</b>
<pre>
 public Dgesvd()
</pre>
<a name="methods"></a>
<h2>
  <img src="images/methods.gif" width=151 height=38 alt="Methods">
</h2>
<a name="dgesvd(java.lang.String, java.lang.String, int, int, double[], int, int, double[], int, double[], int, int, double[], int, int, double[], int, int, org.netlib.util.intW)"><img src="images/green-ball.gif" width=12 height=12 alt=" o "></a>
<a name="dgesvd"><b>dgesvd</b></a>
<pre>
 public static void dgesvd(String jobu,
                           String jobvt,
                           int m,
                           int n,
                           double a[],
                           int _a_offset,
                           int lda,
                           double s[],
                           int _s_offset,
                           double u[],
                           int _u_offset,
                           int ldu,
                           double vt[],
                           int _vt_offset,
                           int ldvt,
                           double work[],
                           int _work_offset,
                           int lwork,
                           <a href="org.netlib.util.intW.html#_top_">intW</a> info)
</pre>
<hr>
<pre>
<a href="packages.html">All Packages</a>  <a href="tree.html">Class Hierarchy</a>  <a href="Package-org.netlib.lapack.html">This Package</a>  <a href="org.netlib.lapack.Dgesv.html#_top_">Previous</a>  <a href="org.netlib.lapack.Dgesvx.html#_top_">Next</a>  <a href="AllNames.html">Index</a></pre>
</body>
</html>
